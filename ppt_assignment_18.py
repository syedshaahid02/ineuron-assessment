# -*- coding: utf-8 -*-
"""PPT_Assignment_18.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zx5VnkShU2i9uAHNLQFPaG8qO1ZFPtzm
"""

#1
def merge_intervals(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]

    for interval in intervals[1:]:
        if interval[0] <= merged[-1][1]:
            merged[-1][1] = max(merged[-1][1], interval[1])
        else:
            merged.append(interval)

    return merged

intervals1 = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(merge_intervals(intervals1))
# Output: [[1, 6], [8, 10], [15, 18]]

intervals2 = [[1, 4], [4, 5]]
print(merge_intervals(intervals2))
# Output: [[1, 5]]

#2
def sort_colors(nums):
    low = 0
    mid = 0
    high = len(nums) - 1

    while mid <= high:
        if nums[mid] == 0:
            nums[mid], nums[low] = nums[low], nums[mid]
            mid += 1
            low += 1
        elif nums[mid] == 1:
            mid += 1
        else:
            nums[mid], nums[high] = nums[high], nums[mid]
            high -= 1

nums1 = [2, 0, 2, 1, 1, 0]
sort_colors(nums1)
print(nums1)
# Output: [0, 0, 1, 1, 2, 2]

nums2 = [2, 0, 1]
sort_colors(nums2)
print(nums2)
# Output: [0, 1, 2]

#3
def first_bad_version(n, isBadVersion):
  """Finds the first bad version in the range [1, n].

  Args:
    n: The number of versions to check.
    isBadVersion: An API function that returns whether version is bad.

  Returns:
    The first bad version, or -1 if no bad versions are found.
  """

  left = 1
  right = n
  while left <= right:
    mid = left + (right - left) // 2
    if isBadVersion(mid):
      right = mid - 1
    else:
      left = mid + 1
  return left if isBadVersion(left) else -1


if __name__ == "__main__":
  bad = 4
  print(first_bad_version(5, lambda version: version == bad))
  bad = 1
  print(first_bad_version(1, lambda version: version == bad))

#4
def maximum_gap(nums):
    if len(nums) < 2:
        return 0

    min_value = min(nums)
    max_value = max(nums)
    n = len(nums)

    if min_value == max_value:
        return 0

    gap = (max_value - min_value) // (n - 1)
    if (max_value - min_value) % (n - 1) != 0:
        gap += 1

    min_buckets = [float('inf')] * n
    max_buckets = [float('-inf')] * n

    for num in nums:
        if num == min_value or num == max_value:
            continue

        index = (num - min_value) // gap
        min_buckets[index] = min(min_buckets[index], num)
        max_buckets[index] = max(max_buckets[index], num)

    max_difference = 0
    previous_max = min_value

    for i in range(n - 1):
        if min_buckets[i] == float('inf') and max_buckets[i] == float('-inf'):
            continue

        max_difference = max(max_difference, min_buckets[i] - previous_max)
        previous_max = max_buckets[i]

    max_difference = max(max_difference, max_value - previous_max)

    return max_difference

nums1 = [3, 6, 9, 1]
print(maximum_gap(nums1))
# Output: 3

nums2 = [10]
print(maximum_gap(nums2))
# Output: 0

#5
def contains_duplicate(nums):
    num_set = set()

    for num in nums:
        if num in num_set:
            return True
        num_set.add(num)

    return False

nums1 = [1, 2, 3, 1]
print(contains_duplicate(nums1))
# Output: True

nums2 = [1, 2, 3, 4]
print(contains_duplicate(nums2))
# Output: False

nums3 = [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]
print(contains_duplicate(nums3))
# Output: True

#6
def find_min_arrows(points):
    if not points:
        return 0

    points.sort(key=lambda x: x[1])
    arrows = 1
    end = points[0][1]

    for i in range(1, len(points)):
        if points[i][0] > end:
            arrows += 1
            end = points[i][1]
        else:
            end = min(end, points[i][1])

    return arrows

points1 = [[10, 16], [2, 8], [1, 6], [7, 12]]
print(find_min_arrows(points1))
# Output: 2

points2 = [[1, 2], [3, 4], [5, 6], [7, 8]]
print(find_min_arrows(points2))
# Output: 4

points3 = [[1, 2], [2, 3], [3, 4], [4, 5]]
print(find_min_arrows(points3))
# Output: 2

#7
def length_of_lis(nums):
    if not nums:
        return 0

    n = len(nums)
    dp = [1] * n

    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)

nums1 = [10, 9, 2, 5, 3, 7, 101, 18]
print(length_of_lis(nums1))
# Output: 4

nums2 = [0, 1, 0, 3, 2, 3]
print(length_of_lis(nums2))
# Output: 4

nums3 = [7, 7, 7, 7, 7, 7, 7]
print(length_of_lis(nums3))
# Output: 1

#8
def find132pattern(nums):
    stack = []
    max_k = float('-inf')

    for i in range(len(nums) - 1, -1, -1):
        if nums[i] < max_k:
            return True

        while stack and stack[-1] < nums[i]:
            max_k = max(max_k, stack.pop())

        stack.append(nums[i])

    return False

nums1 = [1, 2, 3, 4]
print(find132pattern(nums1))
# Output: False

nums2 = [3, 1, 4, 2]
print(find132pattern(nums2))
# Output: True

nums3 = [-1, 3, 2, 0]
print(find132pattern(nums3))
# Output: True



