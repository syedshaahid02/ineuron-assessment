# -*- coding: utf-8 -*-
"""Assignment-15.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13mBJ5jrUIznaOL1cGpQnGJg0_sL0_CMl
"""

#1
def findNextGreaterElements(arr):
    stack = []
    result = [-1] * len(arr)

    for i in range(len(arr)-1, -1, -1):
        while stack and stack[-1] <= arr[i]:
            stack.pop()

        if stack:
            result[i] = stack[-1]

        stack.append(arr[i])

    return result

# Example 1
arr1 = [1, 3, 2, 4]
output1 = findNextGreaterElements(arr1)
print(output1)

# Example 2
arr2 = [4, 5, 2, 25]
output2 = findNextGreaterElements(arr2)
print(output2)

#2
def findNearestSmallerElements(a):
    stack = []
    result = [-1] * len(a)

    for i in range(len(a)):
        while stack and stack[-1] >= a[i]:
            stack.pop()

        if stack:
            result[i] = stack[-1]

        stack.append(a[i])

    return result

# Example 1
a1 = [1, 6, 2]
output1 = findNearestSmallerElements(a1)
print(output1)

# Example 2
a2 = [5, 3, 1, 2, 4]
output2 = findNearestSmallerElements(a2)
print(output2)

#3
from collections import deque

class Stack:
    def __init__(self):
        self.q1 = deque()
        self.q2 = deque()

    def push(self, value):
        # Add the new element to the empty queue
        self.q2.append(value)

        # Transfer all elements from q1 to q2
        while self.q1:
            self.q2.append(self.q1.popleft())

        # Swap the names of q1 and q2
        self.q1, self.q2 = self.q2, self.q1

    def pop(self):
        # If q1 is empty, the stack is empty
        if not self.q1:
            return None

        # Return the top element from q1
        return self.q1.popleft()

    def is_empty(self):
        # Check if q1 is empty
        return len(self.q1) == 0

# Example 1
stack1 = Stack()
stack1.push(2)
stack1.push(3)
print(stack1.pop())
stack1.push(4)
print(stack1.pop())


stack2 = Stack()
stack2.push(5)
stack2.push(6)
print(stack2.pop())
stack2.push(7)
print(stack2.pop())

#4
def reverseStack(St):
    if len(St) <= 1:
        return

    top = St.pop()
    reverseStack(St)
    insertAtBottom(St, top)

def insertAtBottom(St, item):
    if len(St) == 0:
        St.append(item)
        return

    top = St.pop()
    insertAtBottom(St, item)
    St.append(top)


St = [3, 2, 1, 7, 6]
reverseStack(St)
print(St)

#5
def reverseString(S):
    stack = []
    for char in S:
        stack.append(char)

    reversed_string = ""
    while stack:
        reversed_string += stack.pop()

    return reversed_string


S1 = "Hello, World!"
reversed_str1 = reverseString(S1)
print(reversed_str1)

#6
def evaluatePostfixExpression(S):
    stack = []
    operators = set(['*', '/', '+', '-'])

    for ch in S:
        if ch.isdigit():
            stack.append(int(ch))
        elif ch in operators:
            operand2 = stack.pop()
            operand1 = stack.pop()

            if ch == '*':
                result = operand1 * operand2
            elif ch == '/':
                result = operand1 / operand2
            elif ch == '+':
                result = operand1 + operand2
            elif ch == '-':
                result = operand1 - operand2

            stack.append(result)

    return stack.pop()


S1 = "231*+9-"
result1 = evaluatePostfixExpression(S1)
print(result1)


S2 = "52*3+"
result2 = evaluatePostfixExpression(S2)
print(result2)

#7
class MinStack:
    def __init__(self):
        self.stack = []
        self.minStack = []

    def push(self, val):
        self.stack.append(val)
        if not self.minStack or val <= self.minStack[-1]:
            self.minStack.append(val)

    def pop(self):
        if self.stack[-1] == self.minStack[-1]:
            self.minStack.pop()
        self.stack.pop()

    def top(self):
        return self.stack[-1]

    def getMin(self):
        return self.minStack[-1]

minStack = MinStack()
minStack.push(-2)
minStack.push(0)
minStack.push(-3)
print(minStack.getMin())
minStack.pop()
print(minStack.top())
print(minStack.getMin())

#8
def trap(height):
    left = 0
    right = len(height) - 1
    leftMax = 0
    rightMax = 0
    water = 0

    while left <= right:
        if height[left] <= height[right]:
            leftMax = max(leftMax, height[left])
            water += leftMax - height[left]
            left += 1
        else:
            rightMax = max(rightMax, height[right])
            water += rightMax - height[right]
            right -= 1

    return water

# Example 1
height1 = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
result1 = trap(height1)
print(result1)

# Example 2
height2 = [4, 2, 0, 3, 2, 5]
result2 = trap(height2)
print(result2)